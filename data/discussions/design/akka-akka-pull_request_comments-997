<viktorklang> Can we come up with a more efficient solution?
<drewhk> Two loops is more efficient, but uglier as well
or we can keep the watchedBy collection sorted
or we can have to watchedBy collections.
or any more ideas you have
<viktorklang> Since the above solution is O(2*N) anyway, there's no need for creating an intermediate collection.

    def sendTerminated(ifLocal: Boolean)(watcher: ActorRef): Unit = 
      watcher match {
        case a: ActorRefScope if a.isLocal == ifLocal =>
          try watcher.tell(terminated, self) catch {
            case NonFatal(t) ⇒ publish(Error(t, self.path.toString, clazz(actor), "deathwatch"))
          }
        case _ => // N/A
      }

    watchedBy foreach sendTerminated(ifLocal = false)
    watchedBy foreach sendTerminated(ifLocal = true)
<patriknw> perhaps add a

    def isLocal: Boolean = host.isEmpty
<drewhk> That's the two loops approach, but much prettier than I thought. I like it.
<viktorklang> @patriknw https://github.com/akka/akka/blob/master/akka-actor/src/main/scala/akka/actor/ActorRef.scala#L165
<drewhk> Do we need this comment anymore if we use ActorRefScope wich Viktor proposed?
<drewhk> Is it safe to ignore ActorRefs without ActorRefScope?
<patriknw> why do we have the try-catch around tell?
<viktorklang> @drewhk Yes, it should be: private[akka] abstract class InternalActorRef extends ActorRef with ScalaActorRef { this: ActorRefScope ⇒

However, you can add ERROR logging there to make sure.
<drewhk> My intuition would be that not all ActorRef's are actual actors, so we might get exceptions when invoking tell. But I am not a dungeon-dweller :)
<viktorklang> I think the try-catch is an artifact from the past where tell was allowed to throw exceptions. However, if it _does_ throw an exception, if we don't catch and continue, the system is broken.
<patriknw> I think that is good
do we have any ActorRef without ActorRefScope? should it be silently ignored?
<patriknw> or just remove the case, if it should never happen
<drewhk> How does logging work from here? I am inside DeathWatch (and ActorCell via self type)
<viktorklang> Did you see my example code above?
<patriknw> but we rely on that tell should not throw exception in other places, to avoid sprinkling this all over the place
<drewhk> I saw publish, but I was not sure if it applies to my case.
<viktorklang> That's true, let's remove and pray :-)
<viktorklang> Why wouldn't it?

    protected final def publish(e: LogEvent): Unit = try system.eventStream.publish(e) catch { case NonFatal(_) ⇒ }
<patriknw> I would let it blow up instead (remove the `case _`)
<viktorklang> The irony is that it _will_ blow up if the default case is removed, since the local-check is done in the guard. So if you remove the default, you haveto make the guard into an if-expression in the closure body instead.
<drewhk> I noticed that already. I just added another case statement without the guard but with matching on ActorRefScope. Of course I can move the guard inside the case statement as well. Which one do you prefer?
<viktorklang> perhaps just scrap the match all together and just do:

    if (watcher.asInstanceOf[ActorRefScope].isLocal == ifLocal)
      watcher.tell(terminated, self)  

<drewhk> Could  sendSystemMessage throw an exception? Because there is a similar catch construct just one method down.
<viktorklang> Not likely, but lets open a ticket about fixing all such occurences separately.
<rkuhn> I am at least half-certain that Addresses may also be interrogated for local-ness, and there ActorRefScope does not help; I’d like to keep this comment; and we should also add an `isLocal` method which encodes this convention.
<rkuhn> +1
<drewhk> But if the Address is the same as our listen address then isLocal should return true. 
<rkuhn> no, Address has nothing to do with the remoting implementation: the address either specifies host/port, in which case it is non-local, or it does not. Address.isLocal only means that this Address cannot be migrated to other systems or nodes without additional information.
<drewhk> Maybe we should use a different name for that function.
isParial? migratable?
WDYT?
<rkuhn> isLocalScope?
<drewhk> locallyDefined? totallyDefined?
<rkuhn> no, it’s really about the scope of the address, not unlike IPv6 addresses (host-only, link-local, global); it is basically the realm within which this address is supposed to be unique; hence I think there should be both

    def hasLocalScope = host.isEmpty
    def hasGlobalScope = host.isDefined
