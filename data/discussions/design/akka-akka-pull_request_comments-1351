<patriknw> `[{}]`
<patriknw> `immutable.IndexedSeq` as api type? Perhaps this is just internal?
<patriknw> no exc message?
<patriknw> no exc message?
<drewhk> I trust you, you trust the spray.io guys who trust the Netty guys :)
<drewhk> Are you sure this is the best possible name? :D
<drewhk> I have to trust you on this part, I have no experience with SslEngine
<rkuhn> it’s pretty internal
<drewhk> Good rename!
<drewhk> [{}], also below
<rkuhn> exactly
<rkuhn> well, it is quite precise …
<rkuhn> I have no idea either, I just trust the spray guys
<patriknw> pretty ;-) OK
<drewhk> Does this need to be immutable?
<drewhk> Yo, Dawg, I put an ack in your Ack, so you can acknowledge while you acknowledge.
<drewhk> What does this mean?
<drewhk> ticket? If there is, link it from the comment.
<drewhk> No separate client code for Scala?
<rkuhn> no, Java must be better served somewhere :-)
<drewhk> So the handler forwards the events to this actor?
<drewhk> I mean people will copy-paste from examples, and it would be not the nicest pattern. Can be fixed later though.
<rkuhn> what do you mean? events are sent here (after being decrypted) and `become` is what makes sense when the connection is established, no?
<bantonsson> I know where the 16665 and the first 1024 come from, but the extra 1024 for compatibility I have no clue. Seems to work for them :wink:
<drewhk> This is the connection manager actor, no? Shouldn't there be separate actors for each inbound client handling the Received events?
<drewhk> Added Björn to trust list :)
<bantonsson> Should we use `[{}]` here as well even though it's a test?
<drewhk> Ok, but create a ticket then :)
<drewhk> Maybe not
<rkuhn> no, this is the per-connection actor only
<viktorklang> Is that your most modestly priced receptacle?
<viktorklang> `hasRemaining` dawg
<viktorklang> `hasRemaining`
<viktorklang> you know it
<viktorklang> Guess what!
<viktorklang> Why is this using its own ByteBuffer allocations instead of using the/a pool?
<rkuhn> these are user writes of arbitrary size, why would we want to spend the effort without benchmarking?
<viktorklang> Btw, why don't we just store the Writes?
<rkuhn> I can only guess (probably to reduce object allocation counts); @sirthias?
<sirthias> For the record: this is the source:
https://github.com/netty/netty/blob/netty-3.6.5.Final/src/main/java/org/jboss/netty/handler/ssl/SslBufferPool.java#L38

However, a `git grep 16665` on the current Netty 4 master turns up empty. Maybe @normanmaurer has access to the latest Netty wisdom as to the required buffer size for preventing BUFFER_OVERFLOWs from the JDK SSLEngine?
<sirthias> Yes, exactly. The `Send` class here is intentionally mutable (through the ByteBuffer), because we want to work with a single instance until its buffer has been encrypted completely (which might take several `encrypt` calls, each of which drains a chunk of the ByteBuffer). Working with ByteStrings here would potentially entail several "slicings" and repeated copies to a ByteBuffer.

It *might* be however, that in the large majority of cases a write can be encrypted in one single go. If so, it could be more efficient to get rid of the `Send` intermediate structure and copy the write ByteString to a ByteBuffer from the pool in the `encrypt` method itself. We could then save the creation of a new HeapByteBuffer at the cost of ByteString slicing and repeated ByteString -> ByteBuffer copies if the write *cannot* be written in one single `encrypt` call. Profiling real-world applications would provide an answer here.
<rkuhn> would it be conceivable to construct a heuristic which switches strategies, e.g. based on size? or would it also need to consider history?
<sirthias> One thing that we can be sure of is: large writes will always be broken down and encrypted in several passes. From the SslBufferPool sizing question above we know that there is a max number of output bytes the SSLEngine will generate with a single `wrap` call. This size is < 20K. So, if no compression is involved we can assume that every write larger than the max output buffer size will not be written in one go. One could assume that writes which are smaller than the max output buffer size (minus a safety margin) will *always* be encrypted in one go. So, provided this hypothesis proves valid in testing, we could use a threshold size of maybe 15K as a heuristic for switching strategies here...
<viktorklang> I'd suggest removing Send() and just cache the Write for now, then we could see if using a pooled ByteBuffer is faster or slower than allocating a new Send and a new ByteBuffer for every thing going thru.
<sirthias> Yes. Thinking about it again the best approach might be to remove the `Send` and, in the `encrypt` method, copy only the next `maxBufferSize` bytes from the write ByteString into a ByteBuffer from the pool and have the SSLEngine `wrap` these bytes into another ByteBuffer from the pool (which we already do). We can then `drop` the actually wrapped number of bytes from the ByteString and recurse until everything has been written.
This costs us two allocations per subsequent iteration: one for the ByteString `drop` and one for the iterator performing the copy to ByteBuffer, but saves us the creation of a HeapByteBuffer per write.
