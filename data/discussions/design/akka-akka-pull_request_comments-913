<viktorklang> Is this guaranteed to exist on all major JVMs + Dalvik?
<viktorklang> What's the use-case?
<viktorklang> This will be terrible, both for performance and memory usage.
<viktorklang> classOf[JavaLogging].getName didn't work?
<viktorklang> Why is this needed at all? How does one discern a companion from the class?
<viktorklang> Instead of this I'd recommend just logging the LogRecord as a LogEvent to the system.eventStream, then in your JavaEventHandler, unpack messages that are LogRecords and just use them straight off the bat.
<fommil> it is optional, with the default being off. Note that this is *not* used by the ActorLogging framework – it's only if someone wants to have the AkkaLogging API available in a non-Actor context (and here it will be implemented by Java Logging)
<fommil> I tried that and got a weird exception. I can look into it again but it was hard to diagnose.
<fommil> Feel free to remove it – I frankly didn't understand why the $ sign was there. If it is the distinguisher between trait and companion, then it makes sense.
<fommil> @viktorklang this part of the code is not used by the ActorSystem – it's just to make your Akka Logging API available to non-Akka parts of the application.

The only part of `JavaLogging` used by the `ActorLogging` is the `logger` field.
<viktorklang> IMO it doesn't make any sense to add a logging API that doesn't integrate with the Akka Logging backend. My suggestion also removes the need for synchronous and Future-based logging.
<rkuhn> You might want to check AkkaSpec.getCallerName for a quicker way to obtain this information. 
<viktorklang> message is already a string
<viktorklang> I still say that it should log LogEvent an EventStream and not use Futures or ExecutionContexts.
<fommil> ok, cool, this is the bit you mean?

```scala
def getCallerName(clazz: Class[_]): String = {
    val s = Thread.currentThread.getStackTrace map (_.getClassName) drop 1 dropWhile (_ matches ".*AkkaSpec.?$")
    val reduced = s.lastIndexWhere(_ == clazz.getName) match {
      case -1 ⇒ s
      case z  ⇒ s drop (z + 1)
    }
    reduced.head.replaceFirst(""".*\.""", "").replaceAll("[^a-zA-Z_0-9]", "_")
  }
```

Is there any profiling that shows it is faster to use the Thread instead of the Throwable?
<viktorklang> The aforementioned function is more important IMO – that there's a JulLoggingAdapter that ships LogRecords to the JulEventHandler that logs them.
<fommil> I'm happy to remove the Future if you really want, but I think this it is a perfectly reasonable approach for many sensible use cases (and I've turned it off by default anyway). I can only see there being a problem with Future creation if the underlying handlers are unable to write to disc quickly enough. I understand Futures are very cheap.

The way I look at it, if somebody's logging requirements become so intensive that they really need to use the power of Akka to overcome limitations in their legacy backend choice, then at least they'll not need to change their log calls. All they'll need to change will be the name of the trait they imported to get logging support.

I'd love to see some performance studies of where Java Logging breaks down – do you have any numbers on this?


I don't think it makes sense to have the `JavaLogging` trait send information to the EventStream, since it is supposed to be a logging implementation of the Akka Logging API without depending on any ActorSystem being in place.

I'm surprised that what you're suggesting –  a trait which exposes a `log` field (exactly like `ActorLogging`)  but doesn't depend on an `ActorSystem` being in place – doesn't already come with Akka. Did I miss that in the docs? I really think it would be a good thing to have. Developers would then have 3 logging choices

1. ActorLogging (when I'm coding an Actor).
2. "AkkaLogging", which uses the EventStream as you suggest.
3. Implementation specific, e.g. JavaLogging. Useful for applications that don't have an actor system.

But the API remains exactly the same in all cases – an `akka.event.Logging` field called `log`.

<fommil> that's what I get for copying and pasting!
<fommil> OK, I'm now using the Thread. It is cleaner to keep the rest of the code the way it is because I need to grab several entries from the `find` result.
<rkuhn> Oh, sorry, mixed that up on the phone: I actually meant ActorSystem.findClassLoader, which uses `sun.reflect.Reflection.getCallerClass` if available. I did some profiling before resorting to that extreme measure: getting a stack trace takes 50µs while each `getCallerClass` takes 700ns (on some popular hardware) and you need only a handful working your way up the call chain.
<patriknw> I can see that you have had a long discussion, and I admit that I have not read all of it, but my instinct tells me that this specialized LoggingAdapter doesn't belong in akka. If you want to log directly to j.u.l. then you should use that api directly. Exactly what does this `JavaLoggingAdapter` solve that the ordinary `LoggingAdapter` together with the above `JavaLoggingEventHandler` can't handle?
<fommil> It allows the Akka Logging API to be used outside of Actor systems.

My argument for why it should be included in Akka is that it consolidates usage of various adhoc Logging APIs to be the Akka Logging API.
<patriknw> My vote for JavaLoggingAdapter: :-1: 
I don't think that is something akka should try to do. Maintenance burden. Why should only j.u.l. be supported?


<patriknw> I think `JavaLoggingEventHandler` is a good thing. An advantage over slf4j with j.u.l. is that it doesn't require any dependencies, but I guess it solved some problem also.
