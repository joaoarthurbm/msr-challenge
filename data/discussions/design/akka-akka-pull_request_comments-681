<viktorklang> This should be pulled out of the trait since it is a constant, put in some object.
<viktorklang> onRouteDefinition closes over "this" in: (rd) ⇒ getRouteDefinitionHandler(rd) and now you're exposing "this" to another Actor.
<viktorklang> can "getRouteDefinitionHandler" return different things throughout the lifecycle of the Consumer? (i.e. why (rd) ⇒ getRouteDefinitionHandler(rd) and not getRouteDefinitionHandler.apply _)
<viktorklang> private[this]?
<viktorklang> private[this]?
<viktorklang> This will mess up message ordering.
<viktorklang> I'm still not on board with this impl, the code here should most probably be implemented as a match though:

    camelObjects match {
       case Some((endpoint, processor)) => produce(endpoint, processor, transformOutgoingMessage(msg), if (oneway) ExchangePattern.InOnly else ExchangePattern.InOut)
       case None => messages = messages + (sender -> msg)
    }
<viktorklang> what happens if activationTracker or registry dies or throws exception?
<viktorklang> These should be in a companion object like usual.
<viktorklang> "cause" does not need to be a val. 
Why is this an Exception and not an AkkaException or similar?
<viktorklang> Same comments as above.
<viktorklang> prefer vars to immutable datastructures over vals to mutable ones.
<viktorklang> What if these terminate?
<viktorklang> remove this
<viktorklang> So a consumer cannot also be a producer? (values get overwritten in the map)
<viktorklang> actors.remove(actorRef).foreach(_.apply(actorRef))

No need for the if block or anything

But mixing the produces and consumers in the same map is wrong, they deserve their own maps, then you do not need to store any functions either, just use 2 immutable sets, one for consumers and one for producers.
<viktorklang> if this throws then you've already added it to camelObjects...
<viktorklang> why?
<viktorklang> why toString twice?
<viktorklang> Why?
<viktorklang> Wasn't there a todo to make this ocnfigurable?
<viktorklang> timeout should probably be a Timeout instead of a Duration, wdyt?
<viktorklang> same comment here as above.
<viktorklang> slick!
<viktorklang> find 1 problem ;-)
<viktorklang> Should also verify that there is 1 activation and 1 deactivation per ref, and that all refs were activated and deactivated.
<viktorklang> Future.sequence(activations.toList) map activationsPromise.success
<viktorklang> Why Vectors and not Sets?
<viktorklang> 10 seconds seem a bit arbitrary, shouldn't it be configured per test?
<RayRoestenburg> ok
<RayRoestenburg> no it should not, so i'll use getRouteDefinition.apply _.
The idea of using functions instead of methods was to limit mutability and closing over the actor instance.
<RayRoestenburg> Ok I'll do that then. whatever floats yr boat ;-)
<RayRoestenburg> ok
<RayRoestenburg> default supervision strategy restart, so they both get restarted, and lose state, so that's not good. I'll add a Resume strategy for all NonFatal errors.
Also add a watch on them and create new ones when they die.
<RayRoestenburg> I'll do an AkkaException. 
<RayRoestenburg> ok will change.
<RayRoestenburg> yes that is not possible (or should not be possible). Producer overrides receive to send everything it receives to an endpoint, so an Actor that is a consumer and a producer would not make sense. Is there some type magic I can add to enforce this? 
<RayRoestenburg> yep, and it will be deregistered through supervisor later. (now that I look at it again it is not exactly right yet)
when It throws, supervisor stops the registrar instead of the producer being registered, which is not good.
 
So what should happen is, it throws, supervisor stops the actorRef in the ActivationException, through Terminated it then deregisters the actorRef.
All clean again.
<RayRoestenburg> I'll take it out, it's not necessary
<RayRoestenburg> Now that you mention it, I think there was a ticket for it, we talked about it and removed the ticket.
I'll add a FIXME
<RayRoestenburg> Yes, better. BTW, Why does Await still use duration? 
<RayRoestenburg> :)
<RayRoestenburg> yes that could be hard :)
<RayRoestenburg> ok
<RayRoestenburg> ah yes nice
<RayRoestenburg> yeah it's arbitrary.  
I'll add an implicit parameter since most of the time you need one of those anyway in the tests.

<RayRoestenburg> cause I'm craaazy like that! ;-) I'll change it.
<RayRoestenburg> Beer? ;-) no idea really... will fix 
<RayRoestenburg> ok
<RayRoestenburg> Ok I'll do that.
<RayRoestenburg> Well, we should at least know about it right, and restart them? I could let the Registry watch them and create fresh ones when that happens?
<RayRoestenburg> ok
<RayRoestenburg> Some options: 
 1. I don't keep the messages when the producer is not ready yet, they just disappear.
 2. I throw an ActivationException when the producer receives a message and is not ready yet.
 3. I mess up the ordering ;-)
 4. like three, but without messing it up, how about if I call produce directly here and pass in the originalSender from the messages. 
Let me know your favorite of these 4
 
<RayRoestenburg> ok
<RayRoestenburg> ok
<RayRoestenburg> I wanted to prevent exactly that, closing over "this". I wanted to basically separate the function from the Actor. So the Actor should just be able to return a function, the user should be able to provide a custom function, and I only want that function to be contained in the message, without a reference to the Actor. Any way you can see how to do that? 
<viktorklang> Not really possible to enforce, what you could do is test with serialization for local sends turned on, then you'll see that you can't serialize the Actor (afaik).
<viktorklang> Oooooor: 

use Stash and stash all incoming messages until CPO is received, then unstash them all?
It does however require that camel actors use the DequeBasedMailbox...

Thoughts?
<viktorklang> Messing up ordering is the worst of them since it breaks the contract of the message sends.
<viktorklang> I don't know whaat the right semantics should be, I just want to know that failures are handled :-)
<viktorklang> Beer? :D
<viktorklang> Would be easy to put a section in the camel config that maps the keys to FQCNs:

akka {
  camel {
    conversions {
       "file" = "java.io.InputStream",
       "pigdog" = "org.awesome.Pigdog",
       …
    }
  }
}


And then just load that from the config when the Extension is created.
<viktorklang> Timeout is for ask
<viktorklang> Weird if the test passes ;-)
<RayRoestenburg> Yeah the message ordering is extremely important, wasnt a serious option ;-)
 
The stash option sounds like a good idea, are there any serious drawbacks to the DequeBasedMailbox? 
What if the user configures a different dispatcher and mailbox for the actor, then it will break right, how to prevent that? throw an exception if they try?
Does that mean you also can't use durable mailboxes in combination with a Producer?   
<RayRoestenburg> :-) thanks, at least you are making me think which is great. 
<RayRoestenburg> Ah man, nothing more awesome than PigDog :D
cool, will do that as well then.
<viktorklang> The other option is to spawn a child that sends the messages. So buffer until CPO is received, when CPO is received spawn a child with the CPO info, then send all the queued messages to the child, then all new messages that come in go straight to the child. No stash needed, just a queue (which of course needs to be bounded in some sense to avoid OOMEs). See any issues with that?
<viktorklang> If the extension you have a reference to ExtendedActorSystem, from that you can do:

    extendedActorSystem.dynamicAccess.getClassFor[AnyRef](fqcn).get (to get the Class loaded in the right ClassLoader)
<viktorklang> You might not want to do plain ".get" as you'll want to escalate it as a configuration problem, see how the other extensions to it (they use recover with rethrow of wrapped exception)
