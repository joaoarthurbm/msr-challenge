Nice abstraction I like it
This is great
We need the guard to guard the access to shutdownSchedule   private var shutdownSchedule  UNSCHEDULED This can be nonvolatile since it is protected by guard withGuardWe can rewrite this function asif futuresdecrementAndGet  0 guard withGuard   if uuidsisEmpty      shutdownSchedule match
Ill experiment a bit with this thanks for being on top of it
I committed your suggested fix above If there are any other changes youd prefer let me know
Oh I tinkered with it got the final tests running now will check your latest commit
Thanks man the other methods were too lucrative compared to these Now you can docamelactivationFutureForfooforeach   a  a  SomeMessage  a  SomeOtherMessage  a  SomeThirdMessageAnd never block yo
thats whassup blockins for suckas
Looks good The consumer can wait in its own ec for registration while others can get an activationFuture on their ec seems more isolatedThat should prevent the possibility that someone is somehow blocking the consumer registration because it all happens in one queue on one ec dispatcher somewhere
Yup and it also doesnt use something arbitrary as the default dispatcher
Cool well caught
this creates two methods one with type Nil and one with type IterableString where one is a bridge method I think we should avoid that when not necessary
yeah always use explicit return parameters for userfacing APIs
different proposal simply make within abstract in ScatterGatherFirstCompletedLike so that it will be picked up from ScatterGatherFirstCompletedRouter apply the same treatment to nrOfInstances and routees since custom routers do not really have to do this if they dont want to
having this in here makes sense other routers may use it also potentially
and not only because it MAY trip up certain IDEs
Good catch I will implement this immediately
PropsTestActor is nicer
Use actorContextactorOfPropsDemocratActor dSame below
All samples should really have Typsafe copyright headers Add a ticket for going through and add that
Why use tell here And why not sender tell fib  More idiomatic Scala
Nicer with RoundRobinRouter5
Use 2 spaces indentation below Should not be userrouter but router
Perhaps worth mentioning that you get these odd names b etc since no address is specified
Use backticks for code not
Why  used in this section Use backticks
Why use AtomicInteger inside an actor Does it escape If not use an Int
Same here Needed
On the other hand could be nice to be explicit So Ill say keep it
Good job I like it
Thanks for your feedback I will update accordingly and push
Ack sorry guys thought we flushed all these out  loled at the hysterical viktorklang
Anything that fails spuriously is hysterical in my world
These default values are marked final now but the type annotations stop them from being constants Is the intention for them to be constants
Yes that was the plan why would the type annotation mess with that
From what I remember a constant definition has to have final val and no type annotation I would also guess that it only covers some types like primitives String arrays of constants
Can confirm that its final val with no type annotation and that general objects cant be constant expressions So    final val defaultDeployId    constant    final val defaultDeployId String    not constant    final val defaultSupervisor  None  not constant
Why what The no type annotation I think it was always speced that way
But what sense does it make
Missing a  here
Very nice douche
Thanks I guess
since it is part of referenceconf this will always be true
Ie the pool config should be commented out
routees  routees filterNot abandonedRouteescontains
should this happen at each message send
Couldnt this be handled inside Poolresize instead
I think that line is meant to call def resizePoolprops Props context ActorContext currentRoutees IndexedSeqActorRef
Ah it shouldnt since the pool is immutable I get it
that is not true note that I use confighasPath which is the user defined config as opposed to deployment which has the default fallfacks includedval deployment  configwithFallbackdefault
if its not done on each message send when is it then to be doneDo you think of some kind of modulusIn that case I think it should be implemented in the RouterPool  and it belongs to the advanced use cases that the user can implement themselves
What do you mean by I think that line is meant to call def resizePoolIsnt that exactly what it does
yes and I wanted to hide this from the user if they implement their own RouterPool
Ah I didnt see that it was in RouterConfig
ah sorry I somehow managed to forget how this works
wrt every call yes I agree that it should be handled in the pool implementation so the hook should stay as is here Down in the default impl I think it should only resize on every Nth message based on the elasticity parameters Otherwise one flip of the AtomicBoolean per message send would be too costly I propose an atomic counter with a threshold and the reduction is done by the one doing the resizing anybody else just always increments
Or you just do a TTAS
On Tue Jan 10 2012 at 1009 AM Roland Kuhn replyreplygithubcom wrote wrt every call yes I agree that it should be handled in the pool implementation so the hook should stay as is here Down in the default impl I think it should only resize on every Nth message based on the elasticity parameters Otherwise one flip of the AtomicBoolean per message send would be too costly I propose an atomic counter with a threshold and the reduction is done by the one doing the resizing anybody else just always incrementsHmm right now the AtomicBoolean is in RouterConfig so that users doesnthave to implement concurrency stuff when writing their own Resizer Whatabout placing the counter and the Nth message check there also but theResizer decide how often by providing a methoddef resizeOnEachNthMessage IntThe config of that belongs to the Resizer impl  Reply to this email directly or view it on GitHub httpsgithubcomjbonerakkacommit8b71bf5bea435cc0ef2caa68a3e6afa4ac01da77commitcomment852491 Patrik NordwallTypesafe httptypesafecom  EnterpriseGrade Scala from the ExpertsTwitter patriknw
Sorry what is a TTASOn Tue Jan 10 2012 at 1010 AM viktorklang replyreplygithubcom wrote Or you just do a TTAS  Reply to this email directly or view it on GitHub httpsgithubcomjbonerakkacommit8b71bf5bea435cc0ef2caa68a3e6afa4ac01da77commitcomment852494 Patrik NordwallTypesafe httptypesafecom  EnterpriseGrade Scala from the ExpertsTwitter patriknw
yes sounds good might be good to call that method on each check though so that the Resizer has full dynamic control
TTAS  CCAS if somethingget  somethingcompareAndSetfalse true Avoids CAS if not needed
On Tue Jan 10 2012 at 1033 AM Roland Kuhn replyreplygithubcom wrote yes sounds good might be good to call that method on each check though so that the Resizer has full dynamic controlYes thats the planThanks for good suggestion  Reply to this email directly or view it on GitHub httpsgithubcomjbonerakkacommit8b71bf5bea435cc0ef2caa68a3e6afa4ac01da77commitcomment852541 Patrik NordwallTypesafe httptypesafecom  EnterpriseGrade Scala from the ExpertsTwitter patriknw
Completely forgot to rewrite this in the Akka style I just had a few minutes to try it and commit it when it worked I will fix it up
nice work BTW it looks like cheating but I was surprised that it actually prevents me from doing the wrong thing Strange how does that work
I only need to return FutureAny from the shift methods so I can capture exceptions The continuations themselves carry the proper type of the method until the last continuation which I stuff the result of that into the Future created in the flow method The problem as you found is having the inferencer find the correct type for the result of the reset methods annotations I dont care about it I just make it a FutureAny because I only use that to get the exceptionAnd probably magic Definitely a bit of magic in there
Hey Derek This commit seems to break scaladoc generation on publishlocal Can you take a look at that
Yeah probably the same as the problem with Futureapply Ill fix it
Commited fix publishlocal should work again
It is really strange that type inference works when compiling but fails when generating scaladocs Thats twice now I have seen that
Yes strange Could be useful for Scala team to have a ticket if it doesnt already exist
ouch of course you didnt cherrypick the merge commit my bad please also add the doc change in there to release20
Which ones I dont have time to scan the entire commit dude httpsgithubcomjbonerakkacommitb4fcc3b2f2d7e534908057750d0086b9c6e20764
just checkout dispatchersrst from master and commit to release20
On Mon Feb 27 2012 at 220 PM Roland Kuhn replyreplygithubcom wrote just checkout dispatchersrst from master and commit to release20I thought I already updated those in both branches  Reply to this email directly or view it on GitHub httpsgithubcomjbonerakkacommitcf6e8b1f1bef43dd12e4efa9f4a193746092a9dfcommitcomment1014854 Viktor KlangAkka Tech LeadTypesafe httpwwwtypesafecom  The software stack for applicationsthat scaleTwitter viktorklang
Ive pushed the changes to releas20 now2012227 iktor lang viktorklanggmailcom On Mon Feb 27 2012 at 220 PM Roland Kuhn  replyreplygithubcom  wrote just checkout dispatchersrst from master and commit to release20 I thought I already updated those in both branches  Reply to this email directly or view it on GitHub httpsgithubcomjbonerakkacommitcf6e8b1f1bef43dd12e4efa9f4a193746092a9dfcommitcomment1014854  Viktor Klang Akka Tech Lead Typesafe httpwwwtypesafecom  The software stack for applications that scale Twitter viktorklang Viktor KlangAkka Tech LeadTypesafe httpwwwtypesafecom  The software stack for applicationsthat scaleTwitter viktorklang
At least I thought I did seems to be messed up over at GH right nowgetting an ssh denied2012227 iktor lang viktorklanggmailcom Ive pushed the changes to releas20 now 2012227 iktor lang viktorklanggmailcom On Mon Feb 27 2012 at 220 PM Roland Kuhn  replyreplygithubcom  wrote just checkout dispatchersrst from master and commit to release20 I thought I already updated those in both branches  Reply to this email directly or view it on GitHub httpsgithubcomjbonerakkacommitcf6e8b1f1bef43dd12e4efa9f4a193746092a9dfcommitcomment1014854  Viktor Klang Akka Tech Lead Typesafe httpwwwtypesafecom  The software stack for applications that scale Twitter viktorklang  Viktor Klang Akka Tech Lead Typesafe httpwwwtypesafecom  The software stack for applications that scale Twitter viktorklang Viktor KlangAkka Tech LeadTypesafe httpwwwtypesafecom  The software stack for applicationsthat scaleTwitter viktorklang
which is the actor that created it
Do not pass mutable actors between
Im guessing the commit of the file called q was accidental
qfile is badass
Scary wonder where that came fromThanks for noticing Can you please remove it if not already donePatrik22 dec 2011 kl 0050 skrev Peter Vlugterreplyreplygithubcom Im guessing the commit of the file called q was accidental    Reply to this email directly or view it on GitHub httpsgithubcomjbonerakkacommit1bce4c39c3e8844037dd5d6feb8402dedfac7374commitcomment814357
Nice Added to the rst doc for dispatchers
Is it possible not to provide an upper limit
Make a trait for BufferPool and make this class privateakka so its just an implementation detailThen I can optimize the crap out of it
Any particular reason why this is an AtomicInteger and not an AtomicBoolan Just for having nice names Unlocked and Locked
you can release the lock prior to the allocation
this does not need to be volatile as it is guarded by a volatile piggyback of the state
If you make takeBufferFromPool private and its always called from acquire you dont even need case Nil because its guarded by poolSize  0 in acquire aboveMaybe one should measure how much spinning costs compared to allocating a new buffer so one could just allocate a new buffer when theres contention though this would maybe just shift the contention to malloc underneath
Thinking more about it I think we should allocate an array instead then the adds and removes do not incur any allocations
Right Since it is currently fixed size anyway an array would fit perfectly
Would you use a simple array or a scalacollectionmutableArrayStack tomake the management of addingremoving items easierOn Thu Jan 17 2013 at 743 AM Johannes Rudolphnotificationsgithubcomwrote Right Since it is currently fixed size anyway an array would fit perfectly  Reply to this email directly or view it on GitHubhttpsgithubcomakkaakkacommit7d89aefb634e6dd2c31ed8f13b6963be4f338352commitcomment2453179
negative size  take random size
multiple releases is possible here making the pool corrupted
I thin drewhk has a point here rename this to locked and make it an AtomicBoolean and drop Unlocked and Locked and use truefalse
I dont understand Arent concurrent accesses synchronized through the lock in addBufferToPool
Scrap that comment about it being guarded It isnt of course Maybe thats what you meant above
I think its deceptive to not release it and not returning a way for the user to know if the release failed
That depends on what exactly the contract of release is I see release as just a notice from the user to the pool that the user wont use this buffer any more and that it can be now freed or reused on a best effort basis I dont see why this would be deceptive Its just a looser contract The buffer will be GCd sooner or later in any caseIf you use free as in malloc you also dont know if a particular buffer will be put back into a free list or given back to the OS at the time of the call or only later on
collection of native memory is fraught with dangers Its not collected on normal GC sweeps
So what do you suggest If we cant control or force releasing native memory the only thing I see we could do is to limit the amount we allocate in the first place But then we could just rely on the JVM limit to do thatWhat we could do is put buffers bigger than the configured size into an extra collection sorted by size maybe only weak referenced and fallback to a more expensive buffer lookup when a bigger buffer is needed
